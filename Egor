import pygame

# Инициализация Pygame
pygame.init()

# Определение цветов
LIGHT_SQUARE = (240, 217, 181)  # Светлая клетка
DARK_SQUARE = (181, 136, 99)   # Темная клетка

# Размеры окна
WIDTH, HEIGHT = 800, 800

# Размеры и количество клеток на игровой доске
ROWS, COLS = 10, 10
CELL_SIZE = WIDTH // COLS

# Создание окна
screen = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption('Шахматная доска 10x10')

# Создание класса для фигур
class Piece:
    def __init__(self, color, type, image):
        self.color = color
        self.type = type
        self.image = image

# Загрузка изображений фигур и изменение их размера
white_rook_image = pygame.transform.scale(pygame.image.load('white_rook_image.png'), (CELL_SIZE, CELL_SIZE))
black_rook_image = pygame.transform.scale(pygame.image.load('black_rook_image.png'), (CELL_SIZE, CELL_SIZE))
white_knight_image = pygame.transform.scale(pygame.image.load('white_knight_image.png'), (CELL_SIZE, CELL_SIZE))
black_knight_image = pygame.transform.scale(pygame.image.load('black_knight_image.png'), (CELL_SIZE, CELL_SIZE))
white_bishop_image = pygame.transform.scale(pygame.image.load('white_bishop_image.png'), (CELL_SIZE, CELL_SIZE))
black_bishop_image = pygame.transform.scale(pygame.image.load('black_bishop_image.png'), (CELL_SIZE, CELL_SIZE))
white_shaman_image = pygame.transform.scale(pygame.image.load('white_shaman_image.png'), (CELL_SIZE, CELL_SIZE))
black_shaman_image = pygame.transform.scale(pygame.image.load('black_shaman_image.png'), (CELL_SIZE, CELL_SIZE))
white_queen_image = pygame.transform.scale(pygame.image.load('white_queen_image.png'), (CELL_SIZE, CELL_SIZE))
black_queen_image = pygame.transform.scale(pygame.image.load('black_queen_image.png'), (CELL_SIZE, CELL_SIZE))
white_king_image = pygame.transform.scale(pygame.image.load('white_king_image.png'), (CELL_SIZE, CELL_SIZE))
black_king_image = pygame.transform.scale(pygame.image.load('black_king_image.png'), (CELL_SIZE, CELL_SIZE))
white_pawn_image = pygame.transform.scale(pygame.image.load('white_pawn_image.png'), (CELL_SIZE, CELL_SIZE))
black_pawn_image = pygame.transform.scale(pygame.image.load('black_pawn_image.png'), (CELL_SIZE, CELL_SIZE))

# Инициализация фигур

pawn1_white = Piece("white", "pawn", white_pawn_image)
pawn2_white = Piece("white", "pawn", white_pawn_image)
pawn3_white = Piece("white", "pawn", white_pawn_image)
pawn4_white = Piece("white", "pawn", white_pawn_image)
pawn5_white = Piece("white", "pawn", white_pawn_image)
pawn6_white = Piece("white", "pawn", white_pawn_image)
pawn7_white = Piece("white", "pawn", white_pawn_image)
pawn8_white = Piece("white", "pawn", white_pawn_image)
pawn9_white = Piece("white", "pawn", white_pawn_image)
pawn10_white = Piece("white", "pawn", white_pawn_image)

rook1_white = Piece("white", "rook", white_rook_image)
knight1_white = Piece("white", "knight", white_knight_image)
bishop1_white = Piece("white", "bishop", white_bishop_image)
shaman1_white = Piece("white", "shaman", white_shaman_image)
queen_white = Piece("white", "queen", white_queen_image)
king_white = Piece("white", "king", white_king_image)
shaman2_white = Piece("white", "shaman", white_shaman_image)
bishop2_white = Piece("white", "bishop", white_bishop_image)
knight2_white = Piece("white", "knight", white_knight_image)
rook2_white = Piece("white", "rook", white_rook_image)

pawn1_black = Piece("black", "pawn", black_pawn_image)
pawn2_black = Piece("black", "pawn", black_pawn_image)
pawn3_black = Piece("black", "pawn", black_pawn_image)
pawn4_black = Piece("black", "pawn", black_pawn_image)
pawn5_black = Piece("black", "pawn", black_pawn_image)
pawn6_black = Piece("black", "pawn", black_pawn_image)
pawn7_black = Piece("black", "pawn", black_pawn_image)
pawn8_black = Piece("black", "pawn", black_pawn_image)
pawn9_black = Piece("black", "pawn", black_pawn_image)
pawn10_black = Piece("black", "pawn", black_pawn_image)

rook1_black = Piece("black", "rook", black_rook_image)
knight1_black = Piece("black", "knight", black_knight_image)
bishop1_black = Piece("black", "bishop", black_bishop_image)
shaman1_black = Piece("black", "shaman", black_shaman_image)
queen_black = Piece("black", "queen", black_queen_image)
king_black = Piece("black", "king", black_king_image)
shaman2_black = Piece("black", "shaman", black_shaman_image)
bishop2_black = Piece("black", "bishop", black_bishop_image)
knight2_black = Piece("black", "knight", black_knight_image)
rook2_black = Piece("black", "rook", black_rook_image)


# Фигуры на доске
pieces = [
    [rook1_black, knight1_black, bishop1_black, shaman1_black, queen_black, king_black, shaman2_black, bishop2_black, knight2_black, rook2_black],
    [pawn1_black, pawn2_black, pawn3_black, pawn4_black, pawn5_black, pawn6_black, pawn7_black, pawn8_black, pawn9_black, pawn10_black],
    [None] * 10,
    [None] * 10,
    [None] * 10,
    [None] * 10,
    [None] * 10,
    [None] * 10,
    [pawn1_white, pawn2_white, pawn3_white, pawn4_white, pawn5_white, pawn6_white, pawn7_white, pawn8_white, pawn9_white, pawn10_white],
    [rook1_white, knight1_white, bishop1_white, shaman1_white, queen_white, king_white, shaman2_white, bishop2_white, knight2_white, rook2_white]
]

selected_piece = None  # Выбранная фигура

# Функция для проверки возможности хода для Ладьи
def valid_move_rook(row, col, new_row, new_col, pieces):
    # Проверяем, что начальная и конечная клетки лежат на доске
    if not (0 <= col < 10 and 0 <= row < 10 and 0 <= new_col < 10 and 0 <= new_row < 10):
        return False

    # Проверяем, что конечная клетка пуста или содержит фигуру другого цвета
    if pieces[new_row][new_col] != None and pieces[new_row][new_col].color == pieces[row][col].color:
        return False

    # Проверяем, что между начальной и конечной клеткой нет других фигур
    if col == new_col:
    # Проверяем вертикальное перемещение
        start_row = min(row, new_row)
        end_row = max(row, new_row)
        for r in range(start_row + 1, end_row):
            if pieces[r][col] != None:
                return False
    else:
    # Проверяем горизонтальное перемещение
        start_col = min(col, new_col)
        end_col = max(col, new_col)
        for c in range(start_col + 1, end_col):
            if pieces[row][c] != None:
                return False

    return True

# Функция для проверки возможности хода для Коня
def valid_move_knight(row, col, new_row, new_col):
    if abs(new_row - row) == 2 and abs(new_col - col) == 1:
        return True
    elif abs(new_row - row) == 1 and abs(new_col - col) == 2:
        return True
    else:
        return False

# Функция для проверки возможности хода для Слона
def valid_move_bishop(row, col, new_row, new_col):
    return abs(new_row - row) == abs(new_col - col)

# Функция для проверки возможности хода для Ферзя
def valid_move_queen(row, col, new_row, new_col):
    return (row == new_row or col == new_col) or (abs(new_row - row) == abs(new_col - col))

# Функция для проверки возможности хода для Короля
def valid_move_king(row, col, new_row, new_col):
    if abs(new_row - row) <= 1 and abs(new_col - col) <= 1:
        return True
    else:
        return False

# Функция для проверки возможности хода для Шамана
def valid_move_shaman(row, col, new_row, new_col):
    if abs(new_row - row) <= 1 and abs(new_col - col) <= 1:
        return True
    else:
        return False

# Функция для проверки возможности хода для Пешки
def valid_move_pawn(row, col, new_row, new_col, player_color):
    if player_color == "white":
        direction = -1
        starting_row = 8
    else:
        direction = 1
        starting_row = 1

    # Передвижение на одну клетку вперед
    if col == new_col and row + direction == new_row and pieces[new_row][new_col] is None:
        return True

    # Передвижение на две клетки вперед из начальной позиции
    if col == new_col and row + 2 * direction == new_row and row == starting_row and pieces[row + direction][col] is None and pieces[new_row][new_col] is None:
        return True

    # Взятие фигуры по диагонали
    if abs(new_col - col) == 1 and row + direction == new_row and pieces[new_row][new_col] is not None and pieces[row][col].color != pieces[new_row][new_col].color:
        return True
    # Взятие вражеской пешки на проходе
    # if abs(new_col - col) == 1 and row + direction == new_row and pieces[new_row][new_col] is None and
    # превращение в фигуру

    return False


# Функция для получения возможных ходов для выбранной фигуры
def get_possible_moves(row, col):
    possible_moves = []
    # Возможные ходы для пешки
    if selected_piece.type == "pawn":
        if player_turn == "white":
            direction = -1
        else:
            direction = 1

        # Проверка возможности хода на одну клетку вперед
        new_row = row + direction
        new_col = col
        if new_row >= 0 and new_row < 10 and new_col >= 0 and new_col < 10 and pieces[new_row][new_col] is None:
            possible_moves.append((new_row, new_col))

        # Проверка возможности хода на две клетки вперед из начальной позиции
        if (player_turn == "white" and row == 8) or (player_turn == "black" and row == 1):
            new_row = row + 2 * direction
            new_col = col
            if new_row >= 0 and new_row < 10 and new_col >= 0 and new_col < 10 and pieces[new_row][new_col] is None and pieces[row + direction][new_col] is None:
                possible_moves.append((new_row, new_col))

        # Проверка возможности взятия фигуры по диагонали
        for i in [-1, 1]:
            new_row = row + direction
            new_col = col + i
            if new_row >= 0 and new_row < 10 and new_col >= 0 and new_col < 10 and pieces[new_row][new_col] is not None and pieces[row][col].color != pieces[new_row][new_col].color:
                possible_moves.append((new_row, new_col))
    if selected_piece.type == 'king':
        for i in range(-1, 2):
            for j in range(-1, 2):
                if i == 0 and j == 0:
                    continue
                new_row = row + i
                new_col = col + j
                if 0 <= new_row < 10 and 0 <= new_col < 10:
                    if pieces[new_row][new_col] is None or pieces[new_row][new_col].color != pieces[row][col].color:
                        possible_moves.append((new_row, new_col))
    if selected_piece.type == 'knight':
        knight_moves = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)]
        for move in knight_moves:
            new_row = row + move[0]
            new_col = col + move[1]
            if 0 <= new_row < 10 and 0 <= new_col < 10:
                if pieces[new_row][new_col] is None or pieces[new_row][new_col].color != pieces[row][col].color:
                    possible_moves.append((new_row, new_col))
    if selected_piece.type == 'rook':
        rook_moves = [(i, 0) for i in range(-9, 10)] + [(0, i) for i in range(-9, 10)]
        for move in rook_moves:
            new_row = row + move[0]
            new_col = col + move[1]
            if 0 <= new_row < 10 and 0 <= new_col < 10:
                if pieces[new_row][new_col] is None or pieces[new_row][new_col].color != pieces[row][col].color:
                    if valid_move_rook(row, col, new_row, new_col, pieces) == True:
                        possible_moves.append((new_row, new_col))
    if selected_piece.type == 'shaman':
        for i in range(-1, 2):
            for j in range(-1, 2):
                if i == 0 and j == 0:
                    continue
                new_row = row + i
                new_col = col + j
                if 0 <= new_row < 10 and 0 <= new_col < 10:
                    if pieces[new_row][new_col] is None or pieces[new_row][new_col].color != pieces[row][col].color:
                        possible_moves.append((new_row, new_col))

    return possible_moves


# Функция для отображения доски и фигур
def draw_board():
    for row in range(ROWS):
        for col in range(COLS):
            color = LIGHT_SQUARE if (row + col) % 2 == 0 else DARK_SQUARE
            pygame.draw.rect(screen, color, (col * CELL_SIZE, row * CELL_SIZE, CELL_SIZE, CELL_SIZE))
            # Отображение изображений фигур на доске
            piece = pieces[row][col]
            if piece:
                screen.blit(piece.image, (col * CELL_SIZE, row * CELL_SIZE))
    for cir in circles:
        pygame.draw.circle(*cir)

# Основной игровой цикл
running = True
selected_piece = None
player_turn = "white"  # Начинает белый игрок
circles =[]
while running:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False

        if event.type == pygame.MOUSEBUTTONDOWN:
            mouse_x, mouse_y = pygame.mouse.get_pos()
            clicked_row = mouse_y // CELL_SIZE
            clicked_col = mouse_x // CELL_SIZE

            if selected_piece is None:
                selected_piece = pieces[clicked_row][clicked_col]
                # Проверка наличия выбранной фигуры и соответствие цвета ходящего игрока
                if selected_piece is not None and selected_piece.color == player_turn:
                    possible_moves = get_possible_moves(clicked_row, clicked_col)
                    position = (clicked_row, clicked_col)
                    print(possible_moves, 'отсюда можно попасть в эти позиции')
                    for move in possible_moves:
                        # Отобразить маркеры или подсветку для возможных ходов
                        move_row, move_col = move
                        circles.append((screen, (0, 255, 0), ((move_col + 0.5) * CELL_SIZE, (move_row + 0.5) * CELL_SIZE), CELL_SIZE//8))
            else:
                new_row, new_col = clicked_row, clicked_col
                if (new_row, new_col) in possible_moves:
                    pieces[new_row][new_col] = selected_piece
                    pieces[position[0]][position[1]] = None
                    player_turn = "black" if player_turn == "white" else "white"
                else:
                    print(possible_moves, 'он не наступил, потому что нельзя')
                circles=[]
                selected_piece = None

    # Отображение доски и фигур
    draw_board()
    pygame.display.flip()

pygame.quit()
