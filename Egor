import pygame

# Инициализация Pygame
pygame.init()

# Определение цветов
LIGHT_SQUARE = (240, 217, 181)  # Светлая клетка
DARK_SQUARE = (181, 136, 99)   # Темная клетка

# Размеры окна
WIDTH, HEIGHT = 800, 800

# Размеры и количество клеток на игровой доске
ROWS, COLS = 10, 10
CELL_SIZE = WIDTH // COLS

# Создание окна
screen = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption('Шахматная доска 10x10')

# Создание класса для фигур
class Piece:
    def __init__(self, color, type, image):
        self.color = color
        self.type = type
        self.image = image

# Загрузка изображений фигур и изменение их размера
white_rook_image = pygame.transform.scale(pygame.image.load('white_rook_image.png'), (CELL_SIZE, CELL_SIZE))
black_rook_image = pygame.transform.scale(pygame.image.load('black_rook_image.png'), (CELL_SIZE, CELL_SIZE))
white_knight_image = pygame.transform.scale(pygame.image.load('white_knight_image.png'), (CELL_SIZE, CELL_SIZE))
black_knight_image = pygame.transform.scale(pygame.image.load('black_knight_image.png'), (CELL_SIZE, CELL_SIZE))
white_bishop_image = pygame.transform.scale(pygame.image.load('white_bishop_image.png'), (CELL_SIZE, CELL_SIZE))
black_bishop_image = pygame.transform.scale(pygame.image.load('black_bishop_image.png'), (CELL_SIZE, CELL_SIZE))
white_shaman_image = pygame.transform.scale(pygame.image.load('white_shaman_image.png'), (CELL_SIZE, CELL_SIZE))
black_shaman_image = pygame.transform.scale(pygame.image.load('black_shaman_image.png'), (CELL_SIZE, CELL_SIZE))
white_queen_image = pygame.transform.scale(pygame.image.load('white_queen_image.png'), (CELL_SIZE, CELL_SIZE))
black_queen_image = pygame.transform.scale(pygame.image.load('black_queen_image.png'), (CELL_SIZE, CELL_SIZE))
white_king_image = pygame.transform.scale(pygame.image.load('white_king_image.png'), (CELL_SIZE, CELL_SIZE))
black_king_image = pygame.transform.scale(pygame.image.load('black_king_image.png'), (CELL_SIZE, CELL_SIZE))
white_pawn_image = pygame.transform.scale(pygame.image.load('white_pawn_image.png'), (CELL_SIZE, CELL_SIZE))
black_pawn_image = pygame.transform.scale(pygame.image.load('black_pawn_image.png'), (CELL_SIZE, CELL_SIZE))

# Инициализация фигур

pawn1_white = Piece("white", "pawn", white_pawn_image)
pawn2_white = Piece("white", "pawn", white_pawn_image)
pawn3_white = Piece("white", "pawn", white_pawn_image)
pawn4_white = Piece("white", "pawn", white_pawn_image)
pawn5_white = Piece("white", "pawn", white_pawn_image)
pawn6_white = Piece("white", "pawn", white_pawn_image)
pawn7_white = Piece("white", "pawn", white_pawn_image)
pawn8_white = Piece("white", "pawn", white_pawn_image)
pawn9_white = Piece("white", "pawn", white_pawn_image)
pawn10_white = Piece("white", "pawn", white_pawn_image)

rook1_white = Piece("white", "rook", white_rook_image)
knight1_white = Piece("white", "knight", white_knight_image)
bishop1_white = Piece("white", "bishop", white_bishop_image)
shaman1_white = Piece("white", "shaman", white_shaman_image)
queen_white = Piece("white", "queen", white_queen_image)
king_white = Piece("white", "king", white_king_image)
shaman2_white = Piece("white", "shaman", white_shaman_image)
bishop2_white = Piece("white", "bishop", white_bishop_image)
knight2_white = Piece("white", "knight", white_knight_image)
rook2_white = Piece("white", "rook", white_rook_image)

pawn1_black = Piece("black", "pawn", black_pawn_image)
pawn2_black = Piece("black", "pawn", black_pawn_image)
pawn3_black = Piece("black", "pawn", black_pawn_image)
pawn4_black = Piece("black", "pawn", black_pawn_image)
pawn5_black = Piece("black", "pawn", black_pawn_image)
pawn6_black = Piece("black", "pawn", black_pawn_image)
pawn7_black = Piece("black", "pawn", black_pawn_image)
pawn8_black = Piece("black", "pawn", black_pawn_image)
pawn9_black = Piece("black", "pawn", black_pawn_image)
pawn10_black = Piece("black", "pawn", black_pawn_image)

rook1_black = Piece("black", "rook", black_rook_image)
knight1_black = Piece("black", "knight", black_knight_image)
bishop1_black = Piece("black", "bishop", black_bishop_image)
shaman1_black = Piece("black", "shaman", black_shaman_image)
queen_black = Piece("black", "queen", black_queen_image)
king_black = Piece("black", "king", black_king_image)
shaman2_black = Piece("black", "shaman", black_shaman_image)
bishop2_black = Piece("black", "bishop", black_bishop_image)
knight2_black = Piece("black", "knight", black_knight_image)
rook2_black = Piece("black", "rook", black_rook_image)


# Фигуры на доске
pieces = [
    [rook1_black, knight1_black, bishop1_black, shaman1_black, queen_black, king_black, shaman2_black, bishop2_black, knight2_black, rook2_black],
    [pawn1_black, pawn2_black, pawn3_black, pawn4_black, pawn5_black, pawn6_black, pawn7_black, pawn8_black, pawn9_black, pawn10_black],
    [None] * 10,
    [None] * 10,
    [None] * 10,
    [None] * 10,
    [None] * 10,
    [None] * 10,
    [pawn1_white, pawn2_white, pawn3_white, pawn4_white, pawn5_white, pawn6_white, pawn7_white, pawn8_white, pawn9_white, pawn10_white],
    [rook1_white, knight1_white, bishop1_white, shaman1_white, queen_white, king_white, shaman2_white, bishop2_white, knight2_white, rook2_white]
]

selected_piece = None  # Выбранная фигура


def check_castle(pieces, row, col, new_row, new_col):
    piece = pieces[row][col]

    # Проверяем, что фигура - король
    if piece != "king":
        return False

    # Проверяем, что движение по вертикали на 2 клетки
    if abs(new_col - col) != 2:
        return False

    # Проверяем, что король и ладья не двигались до этого
    if col == 0:
        rook = pieces[row][0]
        if rook != "rook":
            return False
        if pieces[row][1] != None or pieces[row][2] != None or pieces[row][3] != None:
            return False

    elif col == 9:
        rook = pieces[row][9]
        if rook != "rook":
            return False
        if pieces[row][7] != None or pieces[row][8] != None:
            return False

    return True

def perform_castle(pieces, row, col, new_row, new_col):
    piece = pieces[row][col]
    pieces[row][col] = ' '

    if new_col == 2:
        pieces[row][0] = None
        pieces[row][3] = "king"
        pieces[row][new_col] = piece
        pieces[row][new_col + 1] = "rook"
    else:
        pieces[row][9] = None
        pieces[row][7] = "rook"
        pieces[row][new_col] = piece
        pieces[row][new_col - 1] = "rook"

# Функция для проверки возможности хода для Ладьи
def valid_move_rook(row, col, new_row, new_col, pieces):
    if not (0 <= col < 10 and 0 <= row < 10 and 0 <= new_col < 10 and 0 <= new_row < 10):
        return False
    if pieces[new_row][new_col] != None and pieces[new_row][new_col].color == pieces[row][col].color:
        return False
    if col == new_col:
        start_row = min(row, new_row)
        end_row = max(row, new_row)
        for r in range(start_row+1, end_row):
            if pieces[r][col] != None:
                return False
    else:
        start_col = min(col, new_col)
        end_col = max(col, new_col)
        for c in range(start_col+1, end_col):
            if pieces[row][c] != None:
                return False

    return True

# Функция для проверки возможности хода для Слона
def valid_move_bishop(row, col, new_row, new_col, pieces):
    if not (0 <= col < 10 and 0 <= row < 10 and 0 <= new_col < 10 and 0 <= new_row < 10):
        return False

    if pieces[new_row][new_col] != None and pieces[new_row][new_col].color == pieces[row][col].color:
        return False
    if abs(new_col - col) != abs(new_row - row):
        return False
    diff_row = new_row - row
    diff_col = new_col - col
    step_row = 1 if diff_row > 0 else -1
    step_col = 1 if diff_col > 0 else -1
    check_row = row + step_row
    check_col = col + step_col
    while check_row != new_row and check_col != new_col:
        if pieces[check_row][check_col] != None:
            return False
        check_row += step_row
        check_col += step_col
    return True

# Функция для проверки возможности хода для Ферзя

def get_possible_moves(row, col):
    possible_moves = []
    # Возможные ходы для пешки
    if selected_piece.type == "pawn":
        if player_turn == "white":
            direction = -1
        else:
            direction = 1

        # Проверка возможности хода на одну клетку вперед
        new_row = row + direction
        new_col = col
        if new_row >= 0 and new_row < 10 and new_col >= 0 and new_col < 10 and pieces[new_row][new_col] is None:
            possible_moves.append((new_row, new_col))




        # Проверка возможности хода на две клетки вперед из начальной позиции
        if (player_turn == "white" and row == 8) or (player_turn == "black" and row == 1):
            new_row = row + 2 * direction
            new_col = col
            if new_row >= 0 and new_row < 10 and new_col >= 0 and new_col < 10 and pieces[new_row][new_col] is None and pieces[row + direction][new_col] is None:
                possible_moves.append((new_row, new_col))

        # Проверка возможности взятия фигуры по диагонали
        for i in [-1, 1]:
            new_row = row + direction
            new_col = col + i
            if new_row >= 0 and new_row < 10 and new_col >= 0 and new_col < 10 and pieces[new_row][new_col] is not None and pieces[row][col].color != pieces[new_row][new_col].color:
                possible_moves.append((new_row, new_col))

        if player_turn == 'black':
            for l in range(0, 10):
                if pieces[0][l] == pawn1_white:
                    pieces[0][l] = queen_white
                if pieces[0][l] == pawn2_white:
                    pieces[0][l] = queen_white
                if pieces[0][l] == pawn3_white:
                    pieces[0][l] = queen_white
                if pieces[0][l] == pawn4_white:
                    pieces[0][l] = queen_white
                if pieces[0][l] == pawn5_white:
                    pieces[0][l] = queen_white
                if pieces[0][l] == pawn6_white:
                    pieces[0][l] = queen_white
                if pieces[0][l] == pawn7_white:
                    pieces[0][l] = queen_white
                if pieces[0][l] == pawn8_white:
                    pieces[0][l] = queen_white
                if pieces[0][l] == pawn9_white:
                    pieces[0][l] = queen_white
                if pieces[0][l] == pawn10_white:
                    pieces[0][l] = queen_white
    if selected_piece.type == 'king':
        for i in range(-1, 2):
            for j in range(-1, 2):
                if i == 0 and j == 0:
                    continue
                new_row = row + i
                new_col = col + j
                if 0 <= new_row < 10 and 0 <= new_col < 10:
                    if pieces[new_row][new_col] is None or pieces[new_row][new_col].color != pieces[row][col].color:
                        possible_moves.append((new_row, new_col))
                    if player_turn == 'white':
                        if (pieces[9][9] == rook2_white and pieces[9][8] == None and pieces[9][7] == None and pieces[9][6] == None and pieces[9][5] == king_white):
                            possible_moves.append((9,7))
                            pieces[9][9] = None
                            pieces[9][6] = rook2_white
                        if (pieces[9][0] == rook1_white and pieces[9][1] == None and pieces[9][2] == None and pieces[9][3] == None and pieces[9][4] == None and pieces[9][5] == king_white):
                            possible_moves.append((9,3))
                            pieces[9][0] = None
                            pieces[9][4] = rook1_white

    if selected_piece.type == 'knight':
        knight_moves = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)]
        for move in knight_moves:
            new_row = row + move[0]
            new_col = col + move[1]
            if 0 <= new_row < 10 and 0 <= new_col < 10:
                if pieces[new_row][new_col] is None or pieces[new_row][new_col].color != pieces[row][col].color:
                    possible_moves.append((new_row, new_col))
    if selected_piece.type == 'rook':
        rook_moves = [(i, 0) for i in range(-9, 10)] + [(0, i) for i in range(-9, 10)]
        for move in rook_moves:
            new_row = row + move[0]
            new_col = col + move[1]
            if 0 <= new_row < 10 and 0 <= new_col < 10:
                if pieces[new_row][new_col] is None or pieces[new_row][new_col].color != pieces[row][col].color:
                    if valid_move_rook(row, col, new_row, new_col, pieces) == True:
                        possible_moves.append((new_row, new_col))
    if selected_piece.type == 'shaman':
        for i in range(-1, 2):
            for j in range(-1, 2):
                if i == 0 and j == 0:
                    continue
                new_row = row + i
                new_col = col + j
                if 0 <= new_row < 10 and 0 <= new_col < 10:
                    if pieces[new_row][new_col] is None or pieces[new_row][new_col].color != pieces[row][col].color:
                        possible_moves.append((new_row, new_col))
    if selected_piece.type == 'bishop':
        bishop_moves = [(i, i) for i in range(-9, 10)] + [(i, -i) for i in range(-9, 10)]
        for move in bishop_moves:
            new_row = row + move[0]
            new_col = col + move[1]
            if 0 <= new_row < 10 and 0 <= new_col < 10:
                if pieces[new_row][new_col] is None or pieces[new_row][new_col].color != pieces[row][col].color:
                    if valid_move_bishop(row, col, new_row, new_col, pieces) == True:
                        possible_moves.append((new_row, new_col))
    if selected_piece.type == 'queen':
        bishop_moves = [(i, i) for i in range(-9, 10)] + [(i, -i) for i in range(-9, 10)]
        for move in bishop_moves:
            new_row = row + move[0]
            new_col = col + move[1]
            if 0 <= new_row < 10 and 0 <= new_col < 10:
                if pieces[new_row][new_col] is None or pieces[new_row][new_col].color != pieces[row][col].color:
                    if valid_move_bishop(row, col, new_row, new_col, pieces) == True:
                        possible_moves.append((new_row, new_col))
        rook_moves = [(i, 0) for i in range(-9, 10)] + [(0, i) for i in range(-9, 10)]
        for move in rook_moves:
            new_row = row + move[0]
            new_col = col + move[1]
            if 0 <= new_row < 10 and 0 <= new_col < 10:
                if pieces[new_row][new_col] is None or pieces[new_row][new_col].color != pieces[row][col].color:
                    if valid_move_rook(row, col, new_row, new_col, pieces) == True:
                        possible_moves.append((new_row, new_col))
    return possible_moves





# Функция для отображения доски и фигур
def draw_board():
    for row in range(ROWS):
        for col in range(COLS):
            color = LIGHT_SQUARE if (row + col) % 2 == 0 else DARK_SQUARE
            pygame.draw.rect(screen, color, (col * CELL_SIZE, row * CELL_SIZE, CELL_SIZE, CELL_SIZE))
            # Отображение изображений фигур на доске
            piece = pieces[row][col]
            if piece:
                screen.blit(piece.image, (col * CELL_SIZE, row * CELL_SIZE))
    for cir in circles:
        pygame.draw.circle(*cir)

# Основной игровой цикл
running = True
selected_piece = None
player_turn = "white"  # Начинает белый игрок
circles =[]
while running:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False

        if event.type == pygame.MOUSEBUTTONDOWN:
            mouse_x, mouse_y = pygame.mouse.get_pos()
            clicked_row = mouse_y // CELL_SIZE
            clicked_col = mouse_x // CELL_SIZE

            if selected_piece is None:
                selected_piece = pieces[clicked_row][clicked_col]
                # Проверка наличия выбранной фигуры и соответствие цвета ходящего игрока
                if selected_piece is not None and selected_piece.color == player_turn:
                    possible_moves = get_possible_moves(clicked_row, clicked_col)
                    position = (clicked_row, clicked_col)
                    print(possible_moves, 'отсюда можно попасть в эти позиции')
                    for move in possible_moves:
                        # Отобразить маркеры или подсветку для возможных ходов
                        move_row, move_col = move
                        circles.append((screen, (0, 128, 0), ((move_col + 0.5) * CELL_SIZE, (move_row + 0.5) * CELL_SIZE), CELL_SIZE//8))
            else:
                new_row, new_col = clicked_row, clicked_col
                if (new_row, new_col) in possible_moves:
                    pieces[new_row][new_col] = selected_piece
                    pieces[position[0]][position[1]] = None
                    player_turn = "black" if player_turn == "white" else "white"
                else:
                    print(possible_moves, 'он не наступил, потому что нельзя')
                circles=[]
                selected_piece = None

    # Отображение доски и фигур
    draw_board()
    pygame.display.flip()

pygame.quit()
